{
  "name": "Telegram Supervisor Agent",
  "nodes": [
    {
      "parameters": {
        "updates": ["message", "callback_query"],
        "additionalFields": {}
      },
      "id": "tg-trigger",
      "name": "Telegram Ingestion",
      "type": "n8n-nodes-base.telegramTrigger",
      "typeVersion": 1.1,
      "position": [240, 400],
      "webhookId": "supervisor-agent-v1",
      "credentials": {
        "telegramApi": {
          "id": "telegram-bot-main",
          "name": "Telegram Bot"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Extract message_id for deduplication\nconst raw = $input.first().json;\nconst message = raw.message || {};\nconst callback = raw.callback_query || {};\nconst callbackMsg = callback.message || {};\n\nconst messageId = message.message_id || callbackMsg.message_id;\nconst chatId = message.chat?.id || callbackMsg.chat?.id;\nconst userId = message.from?.id || callback.from?.id;\nconst text = (message.text || callback.data || '').trim();\n\nif (!messageId || !chatId) {\n  throw new Error('Could not extract message_id or chat_id from Telegram update');\n}\n\nreturn {\n  json: {\n    message_id: messageId,\n    chat_id: chatId,\n    user_id: userId,\n    message_text: text,\n    raw: raw\n  }\n};"
      },
      "id": "extract-message-id",
      "name": "Extract Message ID",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 400]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO telegram_message_log (message_id, chat_id, user_id, message_text, status)\nVALUES ($1, $2, $3, $4, 'processing')\nON CONFLICT (message_id) DO NOTHING\nRETURNING message_id;",
        "options": {
          "queryReplacement": "={{ $json.message_id }},={{ $json.chat_id }},={{ $json.user_id }},={{ $json.message_text }}"
        }
      },
      "id": "check-duplicate",
      "name": "Check Duplicate",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [680, 400],
      "credentials": {
        "postgres": {
          "id": "cd-postgres-main",
          "name": "CD PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "duplicate-check",
              "leftValue": "={{ $json.length === 0 }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "is-duplicate",
      "name": "Is Duplicate?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [900, 400]
    },
    {
      "parameters": {
        "jsCode": "// Log duplicate message skip\nconst ctx = $('Extract Message ID').first().json;\n\nconsole.log(`DUPLICATE_SKIPPED: message_id=${ctx.message_id}, chat_id=${ctx.chat_id}`);\n\nreturn {\n  json: {\n    status: 'duplicate_skipped',\n    message_id: ctx.message_id,\n    chat_id: ctx.chat_id\n  }\n};"
      },
      "id": "skip-duplicate",
      "name": "Skip Duplicate",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1120, 280]
    },
    {
      "parameters": {
        "jsCode": "// Extract and normalize Telegram input for processing\nconst ctx = $('Extract Message ID').first().json;\nconst raw = ctx.raw;\nconst message = raw.message || {};\nconst callback = raw.callback_query || {};\nconst callbackMsg = callback.message || {};\n\nconst chatId = message.chat?.id || callbackMsg.chat?.id;\nconst text = (message.text || callback.data || '').trim();\nconst user = message.from?.username || callback.from?.username || 'User';\nconst firstName = message.from?.first_name || callback.from?.first_name || 'Friend';\nconst messageId = ctx.message_id;\n\nif (!chatId) {\n  throw new Error('Could not extract chat_id from Telegram update');\n}\n\nreturn {\n  json: {\n    chatId: String(chatId),\n    messageId: messageId,\n    text,\n    user,\n    firstName,\n    timestamp: new Date().toISOString()\n  }\n};"
      },
      "id": "parse-input",
      "name": "Parse Input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1120, 520]
    },
    {
      "parameters": {
        "jsCode": "// Log incoming message for debugging and audit trail\nconst ctx = $input.first().json;\nconst executionId = $execution.id || 'N/A';\nconst timestamp = new Date().toISOString();\n\nconst logEntry = {\n  event: 'message_received',\n  timestamp,\n  chatId: ctx.chatId,\n  user: ctx.user,\n  messageLength: (ctx.text || '').length,\n  executionId,\n  messageId: ctx.messageId,\n  rawText: ctx.text?.substring(0, 100) // First 100 chars for privacy\n};\n\nconsole.log('SUPERVISOR_AGENT_INCOMING:', JSON.stringify(logEntry));\n\n// Pass through original data\nreturn { json: ctx };"
      },
      "id": "log-incoming",
      "name": "Log Incoming Message",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1340, 360]
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "={{ $json.chatId }}",
        "tableName": "chat_memory",
        "contextWindowLength": 13
      },
      "id": "postgres-memory",
      "name": "Chat Memory",
      "type": "@n8n/n8n-nodes-langchain.memoryPostgresChat",
      "typeVersion": 1,
      "position": [1560, 680],
      "credentials": {
        "postgres": {
          "id": "cd-postgres-main",
          "name": "CD PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "options": {
          "systemMessage": "You are CYBER-SQUIRE, Emmanuel Tigoue's AI operations commander. You maintain Consultative Authority - you advise decisively, not passively.\n\n## CORE IDENTITY\n- User: Emmanuel (ET), Security Solutions Architect (CASP+, CCNA), Sickle Cell warrior\n- Framework: 12-Week Year (12WY) with ADHD-optimized execution\n- Energy: Finite and precious - every interaction must be high-ROI\n\n## RESPONSE FORMAT (ADHD-FRIENDLY)\n1. Lead with the answer - no preambles\n2. Use bullets and visual hierarchy\n3. Bold key actions: **Do this now**\n4. Keep responses under 200 words unless detail requested\n5. End with ONE clear next action\n\n## AVAILABLE TOOLS\nYou have access to specialized sub-workflows. Call them when appropriate:\n\n1. **ADHD_Commander** - When user needs:\n   - Focus task selection from Notion\n   - Help with analysis paralysis\n   - Keywords: focus, task, what should I do, priority, stuck\n\n2. **Finance_Manager** - When user mentions:\n   - Money, expenses, income, payments\n   - AWS costs, subscriptions, debt\n   - Keywords: paid, spent, earned, cost, bill, money\n\n3. **System_Status** - When user asks about:\n   - Infrastructure health, system status\n   - Service availability, resource usage\n   - Keywords: server, EC2, health, running, status\n\n## TOOL ROUTING EXAMPLES\n\n**System Status Tool:**\n- \"Check system health\" → System_Status\n- \"How is the server doing?\" → System_Status\n- \"Are all services running?\" → System_Status\n- \"What's the EC2 status?\" → System_Status\n- \"Is everything okay with the infrastructure?\" → System_Status\n- \"System status report\" → System_Status\n\n**ADHD Commander Tool:**\n- \"What should I work on?\" → ADHD_Commander\n- \"What's on my plate today?\" → ADHD_Commander\n- \"I'm stuck, what's the priority task?\" → ADHD_Commander\n- \"Give me a focus task\" → ADHD_Commander\n- \"Help me choose what to do\" → ADHD_Commander\n- \"I don't know where to start\" → ADHD_Commander\n\n**Finance Manager Tool:**\n- \"Log $50 for groceries\" → Finance_Manager\n- \"I paid rent today\" → Finance_Manager\n- \"Track AWS bill\" → Finance_Manager\n- \"What's my debt status?\" → Finance_Manager\n- \"I spent money on...\" → Finance_Manager\n- \"Record this expense\" → Finance_Manager\n\n**General Conversation (no tool call):**\n- \"Hello\" → Direct friendly response\n- \"Thanks for the help\" → Direct acknowledgment\n- \"How are you?\" → Direct conversational response\n- \"Tell me about...\" → Direct answer with context\n\n## ROUTING RULES\n1. **Match INTENT not keywords** - understand what the user is trying to accomplish\n2. **If 70%+ confident** → call the appropriate tool directly without asking\n3. **If <70% confident** → ask ONE clarifying question\n4. **If completely unclear** → respond with available capabilities\n5. **Never say \"I don't have that capability\"** - suggest the closest tool or provide helpful alternatives\n6. **For simple greetings/thanks** → respond directly, no tool needed\n7. **When in doubt** → call the tool; false positives are better than missed opportunities\n\n## FALLBACK HANDLING\nWhen user input is unclear, ambiguous, or nonsensical (gibberish), use this confidence-based approach:\n\n**HIGH CONFIDENCE (70%+)** - Clear intent detected:\n- Call the appropriate tool directly\n- Respond with decisive action\n- Example: \"Check system\" → System_Status (clear mapping)\n\n**MEDIUM CONFIDENCE (40-70%)** - Partial match:\n- Ask ONE clarifying question\n- Suggest the likely tool\n- Example: \"Things broken?\" → \"Do you want me to check system health, or is this about a specific task?\"\n\n**LOW CONFIDENCE (<40%)** - Gibberish/unclear:\n- DO NOT error or say \"I don't understand\"\n- Respond with helpful orientation:\n  * \"I can help you with: tasks (ADHD Commander), money tracking (Finance Manager), or system health (System Status). What would be most useful right now?\"\n- Keep response under 100 words\n- Maintain friendly, consultative tone\n\n**FALLBACK TRIGGERS:**\n- Random character strings (asdf, qwer, 123)\n- Emoji-only messages\n- Language not recognized as English\n- Zero keywords matching any tool\n- Message shorter than 3 characters (unless greeting)\n\n**NEVER:**\n- Apologize excessively\n- Use phrases like \"I'm confused\" or \"I don't have that capability\"\n- Offer more than 3 options at once (ADHD-friendly)\n- Generate walls of text for unclear input\n\n## CONSULTATIVE AUTHORITY\n- Don't ask \"would you like me to...\" - just do it\n- Provide recommendations, not options\n- Manage energy: \"This can wait until tomorrow\" is valid advice\n- Reference previous conversation context when relevant\n\n## SICKLE CELL AWARENESS\n- High pain days = reduce cognitive load\n- Suggest breaks and pacing when sessions are long\n- Never guilt-trip about productivity\n\nCurrent time context is provided in each message. Use it for time-aware recommendations."
        }
      },
      "id": "ai-agent",
      "name": "Supervisor Agent",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.6,
      "position": [1560, 520]
    },
    {
      "parameters": {
        "modelId": "qwen2.5:7b",
        "options": {
          "temperature": 0.4,
          "numPredict": 512
        }
      },
      "id": "ollama-model",
      "name": "Ollama Qwen",
      "type": "@n8n/n8n-nodes-langchain.lmChatOllama",
      "typeVersion": 1,
      "position": [1560, 300],
      "credentials": {
        "ollamaApi": {
          "id": "Ym2DLXwZDPjfqjdg",
          "name": "Ollama account"
        }
      }
    },
    {
      "parameters": {
        "name": "ADHD_Commander",
        "description": "Call this tool when the user needs task prioritization, focus guidance, or help deciding what to work on. Use for queries about task selection, productivity, 'what should I do next', analysis paralysis, or requesting the highest-priority action. Examples: 'what's on my plate', 'give me a task', 'what should I focus on', 'I'm stuck'. Returns AI-selected task from Notion board with reasoning.",
        "workflowId": {
          "__rl": true,
          "value": "LBIatPU7RFpT7QXX",
          "mode": "id"
        }
      },
      "id": "tool-adhd",
      "name": "ADHD Commander Tool",
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "typeVersion": 1.1,
      "position": [1400, 680]
    },
    {
      "parameters": {
        "name": "Finance_Manager",
        "description": "Call this tool for any financial tracking, transaction logging, or money-related queries. Use when user mentions expenses, income, payments, bills, subscriptions, debt status, or AWS costs. Examples: 'log $50 for groceries', 'paid rent', 'what's my debt status', 'track AWS bill'. Automatically categorizes and logs transactions to ledger.",
        "workflowId": {
          "__rl": true,
          "value": "98C69UAeJH3pFdhC",
          "mode": "id"
        }
      },
      "id": "tool-finance",
      "name": "Finance Manager Tool",
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "typeVersion": 1.1,
      "position": [1720, 680]
    },
    {
      "parameters": {
        "name": "System_Status",
        "description": "Call this tool when the user wants to check infrastructure health, system status, or service availability. Use for queries about EC2, Docker containers, n8n, Ollama, PostgreSQL, disk space, memory usage, or general 'is everything running?' questions. Examples: 'check system health', 'how is the server', 'are all services up', 'system status report'. Returns formatted health check with container status and resource usage.",
        "workflowId": {
          "__rl": true,
          "value": "SYSTEM_STATUS_WORKFLOW_ID",
          "mode": "id"
        }
      },
      "id": "tool-system-status",
      "name": "System Status Tool",
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "typeVersion": 1.1,
      "position": [1240, 680]
    },
    {
      "parameters": {
        "jsCode": "// Enhanced routing decision logging with multi-signal confidence estimation\nconst agent = $input.first().json;\nconst inputCtx = $('Parse Input').first().json;\nconst timestamp = new Date().toISOString();\nconst executionId = $execution.id || 'N/A';\n\n// Extract tool calls if any\nconst toolCalls = agent.intermediate_steps || [];\nconst toolNames = toolCalls.map(step => step.tool || 'unknown');\n\n// Multi-signal confidence estimation\nconst inputText = inputCtx.text || '';\nconst responseText = agent.output || '';\n\n// Signal 1: Tool usage (highest confidence)\nlet toolConfidence = 0;\nif (toolNames.length > 0 && !toolNames.includes('unknown')) {\n  toolConfidence = 100;\n} else if (toolNames.length === 0 && responseText.length > 50) {\n  toolConfidence = 60; // Direct response, medium confidence\n} else {\n  toolConfidence = 30; // No tool, short response\n}\n\n// Signal 2: Input clarity (keyword density)\nconst keywords = ['task', 'focus', 'money', 'paid', 'spent', 'system', 'status', 'health', 'server', 'help', 'what'];\nconst foundKeywords = keywords.filter(kw => inputText.toLowerCase().includes(kw));\nconst keywordConfidence = Math.min(foundKeywords.length * 25, 100);\n\n// Signal 3: Input length and structure\nconst lengthConfidence = inputText.length > 5 ? 70 : (inputText.length > 2 ? 40 : 10);\n\n// Signal 4: Response specificity (not a fallback message)\nconst isFallback = responseText.includes('I can help you with') || \n                   responseText.includes('What would be most useful');\nconst specificityConfidence = isFallback ? 20 : 80;\n\n// Weighted average\nconst confidenceScore = Math.round(\n  (toolConfidence * 0.4) + \n  (keywordConfidence * 0.25) + \n  (lengthConfidence * 0.15) + \n  (specificityConfidence * 0.2)\n);\n\n// Classify confidence level\nlet confidenceLevel = 'LOW';\nif (confidenceScore >= 70) confidenceLevel = 'HIGH';\nelse if (confidenceScore >= 40) confidenceLevel = 'MEDIUM';\n\n// Detect fallback triggers\nconst fallbackTriggers = [];\nif (inputText.length < 3 && !['hi', 'hey', 'yo'].includes(inputText.toLowerCase())) {\n  fallbackTriggers.push('too_short');\n}\nif (/^[^a-zA-Z0-9\\s]{3,}$/.test(inputText)) {\n  fallbackTriggers.push('emoji_only');\n}\nif (/^[a-z]{4,}$/i.test(inputText) && foundKeywords.length === 0) {\n  fallbackTriggers.push('random_characters');\n}\nif (foundKeywords.length === 0 && inputText.length > 5) {\n  fallbackTriggers.push('no_keywords');\n}\n\nconst logEntry = {\n  event: 'routing_decision',\n  timestamp,\n  executionId,\n  chat_id: inputCtx.chatId,\n  user: inputCtx.user,\n  // Routing decision\n  tools_called: toolNames,\n  tool_count: toolNames.length,\n  // Confidence signals\n  confidence_score: confidenceScore,\n  confidence_level: confidenceLevel,\n  signal_tool: toolConfidence,\n  signal_keywords: keywordConfidence,\n  signal_length: lengthConfidence,\n  signal_specificity: specificityConfidence,\n  // Input analysis\n  input_length: inputText.length,\n  keywords_found: foundKeywords,\n  fallback_triggers: fallbackTriggers,\n  is_fallback_response: isFallback,\n  // Response metadata\n  response_length: responseText.length,\n  // For PostgreSQL storage (prepared for routing_metrics table)\n  sql_ready: true\n};\n\nconsole.log('ROUTING_DECISION:', JSON.stringify(logEntry));\n\n// Pass through original agent output with confidence metadata\nreturn { \n  json: {\n    ...agent,\n    _confidence: {\n      score: confidenceScore,\n      level: confidenceLevel,\n      signals: {\n        tool: toolConfidence,\n        keywords: keywordConfidence,\n        length: lengthConfidence,\n        specificity: specificityConfidence\n      }\n    }\n  }\n};"
      },
      "id": "log-routing-decision",
      "name": "Log Routing Decision",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1680, 520]
    },
    {
      "parameters": {
        "jsCode": "const ctx = $('Parse Input').first().json;\nconst agent = $input.first().json;\n\n// Extract agent response\nlet response = agent.output || agent.text || 'Processing complete.';\n\n// Truncate if too long for Telegram (4096 char limit)\nif (response.length > 4000) {\n  response = response.substring(0, 3997) + '...';\n}\n\nreturn {\n  json: {\n    chatId: ctx.chatId,\n    messageId: ctx.messageId,\n    text: response\n  }\n};"
      },
      "id": "format-output",
      "name": "Format Output",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1900, 520]
    },
    {
      "parameters": {
        "jsCode": "// Log outgoing response for debugging and audit trail\nconst startTime = $('Log Incoming Message').first().json.timestamp;\nconst response = $input.first().json;\nconst timestamp = new Date().toISOString();\nconst executionId = $execution.id || 'N/A';\n\n// Calculate latency\nconst latencyMs = startTime \n  ? new Date(timestamp).getTime() - new Date(startTime).getTime() \n  : null;\n\nconst logEntry = {\n  event: 'message_sent',\n  timestamp,\n  chatId: response.chatId,\n  responseLength: (response.text || '').length,\n  latencyMs,\n  executionId,\n  messageId: response.messageId\n};\n\nconsole.log('SUPERVISOR_AGENT_OUTGOING:', JSON.stringify(logEntry));\n\n// Pass through response data\nreturn { json: response };"
      },
      "id": "log-outgoing",
      "name": "Log Outgoing Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2120, 520]
    },
    {
      "parameters": {
        "chatId": "={{ $json.chatId }}",
        "text": "={{ $json.text }}",
        "additionalFields": {
          "parse_mode": "Markdown"
        }
      },
      "id": "send-response",
      "name": "Send Response",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [2340, 520],
      "credentials": {
        "telegramApi": {
          "id": "telegram-bot-main",
          "name": "Telegram Bot"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE telegram_message_log\nSET status = 'completed', processed_at = NOW()\nWHERE message_id = $1;",
        "options": {
          "queryReplacement": "={{ $json.messageId }}"
        }
      },
      "id": "mark-complete",
      "name": "Mark Complete",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [2560, 520],
      "credentials": {
        "postgres": {
          "id": "cd-postgres-main",
          "name": "CD PostgreSQL"
        }
      }
    }
  ],
  "connections": {
    "Telegram Ingestion": {
      "main": [[{ "node": "Extract Message ID", "type": "main", "index": 0 }]]
    },
    "Extract Message ID": {
      "main": [[{ "node": "Check Duplicate", "type": "main", "index": 0 }]]
    },
    "Check Duplicate": {
      "main": [[{ "node": "Is Duplicate?", "type": "main", "index": 0 }]]
    },
    "Is Duplicate?": {
      "main": [
        [{ "node": "Skip Duplicate", "type": "main", "index": 0 }],
        [{ "node": "Parse Input", "type": "main", "index": 0 }]
      ]
    },
    "Parse Input": {
      "main": [[{ "node": "Log Incoming Message", "type": "main", "index": 0 }]]
    },
    "Log Incoming Message": {
      "main": [[{ "node": "Supervisor Agent", "type": "main", "index": 0 }]]
    },
    "Chat Memory": {
      "ai_memory": [[{ "node": "Supervisor Agent", "type": "ai_memory", "index": 0 }]]
    },
    "Ollama Qwen": {
      "ai_languageModel": [[{ "node": "Supervisor Agent", "type": "ai_languageModel", "index": 0 }]]
    },
    "ADHD Commander Tool": {
      "ai_tool": [[{ "node": "Supervisor Agent", "type": "ai_tool", "index": 0 }]]
    },
    "Finance Manager Tool": {
      "ai_tool": [[{ "node": "Supervisor Agent", "type": "ai_tool", "index": 0 }]]
    },
    "System Status Tool": {
      "ai_tool": [[{ "node": "Supervisor Agent", "type": "ai_tool", "index": 0 }]]
    },
    "Supervisor Agent": {
      "main": [[{ "node": "Log Routing Decision", "type": "main", "index": 0 }]]
    },
    "Log Routing Decision": {
      "main": [[{ "node": "Format Output", "type": "main", "index": 0 }]]
    },
    "Format Output": {
      "main": [[{ "node": "Log Outgoing Response", "type": "main", "index": 0 }]]
    },
    "Log Outgoing Response": {
      "main": [[{ "node": "Send Response", "type": "main", "index": 0 }]]
    },
    "Send Response": {
      "main": [[{ "node": "Mark Complete", "type": "main", "index": 0 }]]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "errorWorkflow": "System: Error Handler"
  },
  "staticData": null,
  "tags": [
    { "name": "12WY" },
    { "name": "Supervisor" },
    { "name": "Agentic" },
    { "name": "Dedup" }
  ],
  "meta": {
    "notes": "Supervisor Agent v3.0 (AI Routing Core): Enhanced AI-driven tool selection with natural language understanding. Features: (1) Intent-based routing with 70% confidence threshold, (2) Routing decision logging for analytics, (3) PostgreSQL message deduplication, (4) 13-message chat memory window. Tools connected: ADHD Commander, Finance Manager, System Status. Satisfies SC-3.1 through SC-3.4.",
    "templateCredsSetupCompleted": true,
    "toolInventory": {
      "ADHD_Commander": "Task prioritization and focus guidance from Notion",
      "Finance_Manager": "Transaction logging and financial tracking",
      "System_Status": "Infrastructure health checks and system monitoring"
    }
  }
}
