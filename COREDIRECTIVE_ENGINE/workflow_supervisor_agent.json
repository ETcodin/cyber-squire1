{
  "name": "Telegram Supervisor Agent",
  "nodes": [
    {
      "parameters": {
        "updates": ["message", "callback_query"],
        "additionalFields": {}
      },
      "id": "tg-trigger",
      "name": "Telegram Ingestion",
      "type": "n8n-nodes-base.telegramTrigger",
      "typeVersion": 1.1,
      "position": [240, 400],
      "webhookId": "supervisor-agent-v1",
      "credentials": {
        "telegramApi": {
          "id": "telegram-bot-main",
          "name": "Telegram Bot"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Extract message_id for deduplication + callback detection\nconst raw = $input.first().json;\nconst message = raw.message || {};\nconst callback = raw.callback_query || {};\nconst callbackMsg = callback.message || {};\n\nconst isCallback = !!callback.id;\nconst messageId = message.message_id || callbackMsg.message_id;\nconst chatId = message.chat?.id || callbackMsg.chat?.id;\nconst userId = message.from?.id || callback.from?.id;\nconst text = (message.text || callback.data || '').trim();\n\n// Calculate button age for callbacks\nlet buttonAge = 0;\nif (isCallback && callbackMsg.date) {\n  buttonAge = Math.floor(Date.now() / 1000) - callbackMsg.date;\n}\n\nif (!chatId) {\n  throw new Error('Could not extract chat_id from Telegram update');\n}\n\nreturn {\n  json: {\n    message_id: messageId || `cb_${callback.id}`,\n    chat_id: chatId,\n    user_id: userId,\n    message_text: text,\n    raw: raw,\n    isCallback,\n    callbackId: callback.id || null,\n    callbackData: callback.data || null,\n    buttonAge\n  }\n};"
      },
      "id": "extract-message-id",
      "name": "Extract Message ID",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 400]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO telegram_message_log (message_id, chat_id, user_id, message_text, status)\nVALUES ($1, $2, $3, $4, 'processing')\nON CONFLICT (message_id) DO NOTHING\nRETURNING message_id;",
        "options": {
          "queryReplacement": "={{ $json.message_id }},={{ $json.chat_id }},={{ $json.user_id }},={{ $json.message_text }}"
        }
      },
      "id": "check-duplicate",
      "name": "Check Duplicate",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [680, 400],
      "credentials": {
        "postgres": {
          "id": "cd-postgres-main",
          "name": "CD PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "duplicate-check",
              "leftValue": "={{ $json.length === 0 }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "is-duplicate",
      "name": "Is Duplicate?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [900, 400]
    },
    {
      "parameters": {
        "jsCode": "// Log duplicate message skip\nconst ctx = $('Extract Message ID').first().json;\n\nconsole.log(`DUPLICATE_SKIPPED: message_id=${ctx.message_id}, chat_id=${ctx.chat_id}`);\n\nreturn {\n  json: {\n    status: 'duplicate_skipped',\n    message_id: ctx.message_id,\n    chat_id: ctx.chat_id\n  }\n};"
      },
      "id": "skip-duplicate",
      "name": "Skip Duplicate",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1120, 180]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "callback-check",
              "leftValue": "={{ $('Extract Message ID').first().json.isCallback === true }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "is-callback",
      "name": "Is Callback?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1120, 400]
    },
    {
      "parameters": {
        "jsCode": "// Phase 8: Callback Handler - Parse callback data and check expiration\nconst ctx = $('Extract Message ID').first().json;\nconst EXPIRATION_SECONDS = 300; // 5 minutes\n\nconst callbackData = ctx.callbackData || '';\nconst buttonAge = ctx.buttonAge || 0;\nconst isExpired = buttonAge > EXPIRATION_SECONDS;\n\n// Parse callback format: action:param1:param2...\nconst parts = callbackData.split(':');\nconst action = parts[0] || 'unknown';\nconst params = parts.slice(1);\n\n// Determine callback type\nlet callbackType = 'unknown';\nif (action.startsWith('yes_') || action.startsWith('no_')) {\n  callbackType = 'confirmation';\n} else if (action === 'set_priority') {\n  callbackType = 'priority';\n} else if (action === 'menu_') {\n  callbackType = 'menu';\n}\n\nconsole.log('CALLBACK_RECEIVED:', JSON.stringify({\n  callbackId: ctx.callbackId,\n  action,\n  params,\n  buttonAge,\n  isExpired,\n  callbackType\n}));\n\nreturn {\n  json: {\n    chatId: String(ctx.chat_id),\n    userId: ctx.user_id,\n    callbackId: ctx.callbackId,\n    callbackData,\n    action,\n    params,\n    buttonAge,\n    isExpired,\n    callbackType,\n    originalMessageId: ctx.raw.callback_query?.message?.message_id\n  }\n};"
      },
      "id": "parse-callback",
      "name": "Parse Callback",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1340, 280]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "expired-check",
              "leftValue": "={{ $json.isExpired === true }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-expired",
      "name": "Button Expired?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1560, 280]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://api.telegram.org/bot{{ $credentials.telegramApi.token }}/answerCallbackQuery",
        "authentication": "none",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ callback_query_id: $json.callbackId, text: '‚è∞ Button expired (>5 min). Please try again.', show_alert: true }) }}",
        "options": {}
      },
      "id": "answer-expired",
      "name": "Answer Expired",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1780, 180],
      "credentials": {
        "telegramApi": {
          "id": "telegram-bot-main",
          "name": "Telegram Bot"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://api.telegram.org/bot{{ $credentials.telegramApi.token }}/answerCallbackQuery",
        "authentication": "none",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ callback_query_id: $json.callbackId, text: '' }) }}",
        "options": {}
      },
      "id": "answer-callback",
      "name": "Acknowledge Callback",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1780, 380],
      "credentials": {
        "telegramApi": {
          "id": "telegram-bot-main",
          "name": "Telegram Bot"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Route callback to appropriate handler\nconst ctx = $('Parse Callback').first().json;\nconst action = ctx.action;\nconst params = ctx.params;\n\nlet responseText = '';\nlet shouldEdit = true;\n\n// Handle confirmation callbacks (yes_/no_)\nif (action.startsWith('yes_')) {\n  const confirmAction = action.replace('yes_', '');\n  responseText = `‚úÖ **Confirmed:** ${confirmAction}\\n\\nExecuting action...`;\n  \n  // Add specific handling\n  if (confirmAction === 'scan') {\n    responseText = `‚úÖ **Scan confirmed**\\n\\nScanning ${params[0] || 'target'}...`;\n  } else if (confirmAction === 'delete') {\n    responseText = `‚úÖ **Delete confirmed**\\n\\nDeleting ${params[0] || 'item'}...`;\n  }\n} else if (action.startsWith('no_')) {\n  const confirmAction = action.replace('no_', '');\n  responseText = `‚ùå **Cancelled:** ${confirmAction}`;\n  \n} else if (action === 'set_priority') {\n  const priority = params[0] || 'medium';\n  const taskId = params[1] || 'unknown';\n  const emoji = { high: 'üî¥', medium: 'üü°', low: 'üü¢' }[priority] || '‚ö™';\n  responseText = `${emoji} Priority set to **${priority}** for task ${taskId}`;\n  \n} else if (action === 'menu') {\n  const selection = params[0] || 'unknown';\n  responseText = `üìã Selected: **${selection}**`;\n  \n} else {\n  responseText = `‚ö†Ô∏è Unknown action: ${action}`;\n}\n\nconsole.log('CALLBACK_ROUTED:', JSON.stringify({\n  action,\n  params,\n  response: responseText.substring(0, 50)\n}));\n\nreturn {\n  json: {\n    chatId: ctx.chatId,\n    messageId: ctx.originalMessageId,\n    text: responseText,\n    shouldEdit,\n    action,\n    params,\n    callbackId: ctx.callbackId\n  }\n};"
      },
      "id": "route-callback",
      "name": "Route Callback",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2000, 380]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://api.telegram.org/bot{{ $credentials.telegramApi.token }}/editMessageText",
        "authentication": "none",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ chat_id: $json.chatId, message_id: $json.messageId, text: $json.text, parse_mode: 'Markdown' }) }}",
        "options": {}
      },
      "id": "edit-callback-message",
      "name": "Edit Message",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2220, 380],
      "credentials": {
        "telegramApi": {
          "id": "telegram-bot-main",
          "name": "Telegram Bot"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO button_interactions (callback_query_id, user_id, action, params, button_age_seconds, is_expired, decision, time_to_decision)\nVALUES ($1, $2, $3, $4, $5, $6, $7, $8)\nON CONFLICT (callback_query_id) DO NOTHING;",
        "options": {
          "queryReplacement": "={{ $('Parse Callback').first().json.callbackId }},={{ $('Parse Callback').first().json.userId }},={{ $('Parse Callback').first().json.action }},={{ JSON.stringify($('Parse Callback').first().json.params) }},={{ $('Parse Callback').first().json.buttonAge }},={{ $('Parse Callback').first().json.isExpired }},={{ $json.action?.startsWith('yes_') ? 'yes' : ($json.action?.startsWith('no_') ? 'no' : $json.action) }},={{ $('Parse Callback').first().json.buttonAge }}"
        }
      },
      "id": "log-button-interaction",
      "name": "Log Button Interaction",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [2440, 380],
      "credentials": {
        "postgres": {
          "id": "cd-postgres-main",
          "name": "CD PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Extract and normalize Telegram input for processing\n// Handles both text messages and voice notes\nconst ctx = $('Extract Message ID').first().json;\nconst raw = ctx.raw;\nconst message = raw.message || {};\nconst callback = raw.callback_query || {};\nconst callbackMsg = callback.message || {};\n\nconst chatId = message.chat?.id || callbackMsg.chat?.id;\nconst text = (message.text || callback.data || '').trim();\nconst user = message.from?.username || callback.from?.username || 'User';\nconst firstName = message.from?.first_name || callback.from?.first_name || 'Friend';\nconst messageId = ctx.message_id;\n\n// Voice detection\nconst voice = message.voice || null;\nconst isVoice = voice !== null;\n\nif (!chatId) {\n  throw new Error('Could not extract chat_id from Telegram update');\n}\n\nreturn {\n  json: {\n    chatId: String(chatId),\n    messageId: messageId,\n    text,\n    user,\n    firstName,\n    timestamp: new Date().toISOString(),\n    // Voice fields\n    isVoice,\n    voice: isVoice ? {\n      file_id: voice.file_id,\n      duration: voice.duration,\n      mime_type: voice.mime_type || 'audio/ogg'\n    } : null\n  }\n};"
      },
      "id": "parse-input",
      "name": "Parse Input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1120, 520]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "voice-check",
              "leftValue": "={{ $json.isVoice === true }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "is-voice",
      "name": "Is Voice?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1340, 520]
    },
    {
      "parameters": {
        "chatId": "={{ $json.chatId }}",
        "text": "Transcribing your voice note...",
        "additionalFields": {}
      },
      "id": "voice-status",
      "name": "Send Transcribing Status",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [1560, 700],
      "credentials": {
        "telegramApi": {
          "id": "telegram-bot-main",
          "name": "Telegram Bot"
        }
      }
    },
    {
      "parameters": {
        "method": "GET",
        "url": "=https://api.telegram.org/bot{{ $credentials.telegramApi.token }}/getFile?file_id={{ $('Parse Input').first().json.voice.file_id }}",
        "authentication": "none",
        "options": {}
      },
      "id": "get-voice-file",
      "name": "Get Voice File Info",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1780, 700],
      "credentials": {
        "telegramApi": {
          "id": "telegram-bot-main",
          "name": "Telegram Bot"
        }
      }
    },
    {
      "parameters": {
        "method": "GET",
        "url": "=https://api.telegram.org/file/bot{{ $credentials.telegramApi.token }}/{{ $json.result.file_path }}",
        "authentication": "none",
        "options": {
          "response": {
            "response": {
              "responseFormat": "file"
            }
          }
        }
      },
      "id": "download-voice",
      "name": "Download Voice File",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2000, 700],
      "credentials": {
        "telegramApi": {
          "id": "telegram-bot-main",
          "name": "Telegram Bot"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://cd-service-whisper:8000/v1/audio/transcriptions",
        "authentication": "none",
        "sendBody": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": [
            {
              "parameterType": "formBinaryData",
              "name": "file",
              "inputDataFieldName": "data"
            },
            {
              "name": "model",
              "value": "base"
            },
            {
              "name": "language",
              "value": "en"
            },
            {
              "name": "response_format",
              "value": "json"
            }
          ]
        },
        "options": {
          "timeout": 30000
        }
      },
      "id": "transcribe-voice",
      "name": "Transcribe Voice",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2220, 700],
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Parse transcription and prepare for AI routing\nconst whisperResponse = $input.first().json;\nconst inputCtx = $('Parse Input').first().json;\n\n// Check if transcription failed\nif (whisperResponse.error || !whisperResponse.text) {\n  console.log('TRANSCRIPTION_FAILED:', JSON.stringify({\n    error: whisperResponse.error || 'No text returned',\n    chatId: inputCtx.chatId\n  }));\n  \n  return {\n    json: {\n      chatId: inputCtx.chatId,\n      messageId: inputCtx.messageId,\n      text: '',\n      transcriptionFailed: true,\n      errorMessage: whisperResponse.error?.message || 'Transcription failed',\n      user: inputCtx.user,\n      firstName: inputCtx.firstName,\n      timestamp: inputCtx.timestamp,\n      isVoice: true,\n      duration: inputCtx.voice?.duration || 0\n    }\n  };\n}\n\nconst transcription = whisperResponse.text.trim();\n\nconsole.log('VOICE_TRANSCRIBED:', JSON.stringify({\n  chatId: inputCtx.chatId,\n  duration: inputCtx.voice?.duration || 0,\n  transcriptionLength: transcription.length\n}));\n\nreturn {\n  json: {\n    chatId: inputCtx.chatId,\n    messageId: inputCtx.messageId,\n    text: transcription,\n    transcriptionFailed: false,\n    user: inputCtx.user,\n    firstName: inputCtx.firstName,\n    timestamp: inputCtx.timestamp,\n    isVoice: true,\n    duration: inputCtx.voice?.duration || 0\n  }\n};"
      },
      "id": "parse-transcription",
      "name": "Parse Transcription",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2440, 700]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "transcription-failed",
              "leftValue": "={{ $json.transcriptionFailed === true }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-transcription",
      "name": "Transcription OK?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [2660, 700]
    },
    {
      "parameters": {
        "chatId": "={{ $json.chatId }}",
        "text": "Sorry, I couldn't transcribe your voice note. Please try again or type your message.",
        "additionalFields": {}
      },
      "id": "voice-error",
      "name": "Send Transcription Error",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [2880, 840],
      "credentials": {
        "telegramApi": {
          "id": "telegram-bot-main",
          "name": "Telegram Bot"
        }
      }
    },
    {
      "parameters": {
        "chatId": "={{ $json.chatId }}",
        "text": "=You said: \"{{ $json.text }}\"",
        "additionalFields": {
          "parse_mode": "Markdown"
        }
      },
      "id": "echo-transcription",
      "name": "Echo Transcription",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [2880, 560],
      "credentials": {
        "telegramApi": {
          "id": "telegram-bot-main",
          "name": "Telegram Bot"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Log incoming message for debugging and audit trail\nconst ctx = $input.first().json;\nconst executionId = $execution.id || 'N/A';\nconst timestamp = new Date().toISOString();\n\nconst logEntry = {\n  event: 'message_received',\n  timestamp,\n  chatId: ctx.chatId,\n  user: ctx.user,\n  messageLength: (ctx.text || '').length,\n  executionId,\n  messageId: ctx.messageId,\n  isVoice: ctx.isVoice || false,\n  voiceDuration: ctx.duration || 0,\n  rawText: ctx.text?.substring(0, 100)\n};\n\nconsole.log('SUPERVISOR_AGENT_INCOMING:', JSON.stringify(logEntry));\n\n// Pass through original data\nreturn { json: ctx };"
      },
      "id": "log-incoming",
      "name": "Log Incoming Message",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1560, 360]
    },
    {
      "parameters": {
        "jsCode": "const inputData = $input.first().json;\nconst startTime = Date.now();\n\nreturn {\n  json: {\n    ...inputData,\n    _execution: {\n      startTime,\n      provider: 'ollama',\n      attemptNumber: 1\n    }\n  }\n};"
      },
      "id": "ollama-wrapper",
      "name": "Ollama Agent Wrapper",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1780, 360]
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "={{ $json.chatId }}",
        "tableName": "chat_memory",
        "contextWindowLength": 13
      },
      "id": "postgres-memory",
      "name": "Chat Memory",
      "type": "@n8n/n8n-nodes-langchain.memoryPostgresChat",
      "typeVersion": 1,
      "position": [2000, 160],
      "credentials": {
        "postgres": {
          "id": "cd-postgres-main",
          "name": "CD PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "options": {
          "systemMessage": "You are CYBER-SQUIRE, Emmanuel Tigoue's AI operations commander. You maintain Consultative Authority - you advise decisively, not passively.\n\n## CORE IDENTITY\n- User: Emmanuel (ET), Security Solutions Architect (CASP+, CCNA), Sickle Cell warrior\n- Framework: 12-Week Year (12WY) with ADHD-optimized execution\n- Energy: Finite and precious - every interaction must be high-ROI\n\n## RESPONSE FORMAT (ADHD-FRIENDLY)\n1. Lead with the answer - no preambles\n2. Use bullets and visual hierarchy\n3. Bold key actions: **Do this now**\n4. Keep responses under 200 words unless detail requested\n5. End with ONE clear next action\n\n## AVAILABLE TOOLS\nYou have access to specialized sub-workflows. Call them when appropriate:\n\n1. **ADHD_Commander** - When user needs:\n   - Focus task selection from Notion\n   - Help with analysis paralysis\n   - Keywords: focus, task, what should I do, priority, stuck\n\n2. **Finance_Manager** - When user mentions:\n   - Money, expenses, income, payments\n   - AWS costs, subscriptions, debt\n   - Keywords: paid, spent, earned, cost, bill, money\n\n3. **System_Status** - When user asks about:\n   - Infrastructure health, system status\n   - Service availability, resource usage\n   - Keywords: server, EC2, health, running, status\n\n## ROUTING RULES\n1. **Match INTENT not keywords** - understand what the user is trying to accomplish\n2. **If 70%+ confident** ‚Üí call the appropriate tool directly without asking\n3. **If <70% confident** ‚Üí ask ONE clarifying question\n4. **For simple greetings/thanks** ‚Üí respond directly, no tool needed\n5. **When in doubt** ‚Üí call the tool; false positives are better than missed opportunities\n\n## CONSULTATIVE AUTHORITY\n- Don't ask \"would you like me to...\" - just do it\n- Provide recommendations, not options\n- Manage energy: \"This can wait until tomorrow\" is valid advice\n- Reference previous conversation context when relevant"
        }
      },
      "id": "ai-agent",
      "name": "Supervisor Agent",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.6,
      "position": [2000, 360]
    },
    {
      "parameters": {
        "modelId": "qwen2.5:7b",
        "options": {
          "temperature": 0.4,
          "numPredict": 512
        }
      },
      "id": "ollama-model",
      "name": "Ollama Qwen",
      "type": "@n8n/n8n-nodes-langchain.lmChatOllama",
      "typeVersion": 1,
      "position": [2200, 160],
      "credentials": {
        "ollamaApi": {
          "id": "Ym2DLXwZDPjfqjdg",
          "name": "Ollama account"
        }
      }
    },
    {
      "parameters": {
        "name": "ADHD_Commander",
        "description": "Call this tool when the user needs task prioritization, focus guidance, or help deciding what to work on.",
        "workflowId": {
          "__rl": true,
          "value": "LBIatPU7RFpT7QXX",
          "mode": "id"
        }
      },
      "id": "tool-adhd",
      "name": "ADHD Commander Tool",
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "typeVersion": 1.1,
      "position": [1800, 160]
    },
    {
      "parameters": {
        "name": "Finance_Manager",
        "description": "Call this tool for any financial tracking, transaction logging, or money-related queries.",
        "workflowId": {
          "__rl": true,
          "value": "98C69UAeJH3pFdhC",
          "mode": "id"
        }
      },
      "id": "tool-finance",
      "name": "Finance Manager Tool",
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "typeVersion": 1.1,
      "position": [2400, 160]
    },
    {
      "parameters": {
        "name": "System_Status",
        "description": "Call this tool when the user wants to check infrastructure health or system status.",
        "workflowId": {
          "__rl": true,
          "value": "SYSTEM_STATUS_WORKFLOW_ID",
          "mode": "id"
        }
      },
      "id": "tool-system-status",
      "name": "System Status Tool",
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "typeVersion": 1.1,
      "position": [1600, 160]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "output-exists",
              "leftValue": "={{ $json.output !== undefined && $json.output !== null && $json.output !== '' }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-success",
      "name": "Check Agent Success",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [2220, 360]
    },
    {
      "parameters": {
        "jsCode": "const inputCtx = $('Log Incoming Message').first().json;\n\nconst systemPrompt = `You are CYBER-SQUIRE, Emmanuel's AI operations commander.\n\n## RESPONSE FORMAT (ADHD-FRIENDLY)\n1. Lead with the answer\n2. Use bullets and visual hierarchy\n3. Bold key actions\n4. Keep under 200 words\n5. End with ONE clear next action\n\nRespond to the user's message below.`;\n\nconst fullPrompt = `${systemPrompt}\\n\\nUser: ${inputCtx.text}\\n\\nRespond as CYBER-SQUIRE.`;\n\nreturn {\n  json: {\n    prompt: fullPrompt,\n    chatId: inputCtx.chatId,\n    messageId: inputCtx.messageId,\n    originalInput: inputCtx.text,\n    _execution: {\n      startTime: $('Ollama Agent Wrapper').first().json._execution.startTime,\n      provider: 'gemini',\n      attemptNumber: 2,\n      fallbackReason: 'ollama_failure'\n    }\n  }\n};"
      },
      "id": "prepare-gemini",
      "name": "Prepare Gemini Fallback",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2340, 500]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key={{ $env.GEMINI_API_KEY }}",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ contents: [{ parts: [{ text: $json.prompt }] }], generationConfig: { temperature: 0.4, maxOutputTokens: 512, topP: 0.95 } }) }}",
        "options": {
          "timeout": 15000
        }
      },
      "id": "call-gemini",
      "name": "Call Gemini API",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2560, 500],
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "const geminiResponse = $input.first().json;\nconst executionMeta = $('Prepare Gemini Fallback').first().json._execution;\n\nif (geminiResponse.error || !geminiResponse.candidates) {\n  throw new Error('Gemini API call failed: ' + (geminiResponse.error?.message || 'No candidates returned'));\n}\n\nconst responseText = geminiResponse.candidates?.[0]?.content?.parts?.[0]?.text || \n                     \"I apologize, but I'm having trouble processing your request.\";\n\nconst endTime = Date.now();\nconst latencyMs = endTime - executionMeta.startTime;\n\nconst markedResponse = responseText + \"\\n\\n_via Gemini fallback_\";\n\nreturn {\n  json: {\n    output: markedResponse,\n    intermediate_steps: [],\n    _metadata: {\n      provider: 'gemini',\n      model: 'gemini-2.0-flash',\n      latencyMs,\n      fallback: true\n    },\n    _execution: executionMeta\n  }\n};"
      },
      "id": "parse-gemini",
      "name": "Parse Gemini Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2780, 500]
    },
    {
      "parameters": {
        "jsCode": "const response = $input.first().json;\nconst inputCtx = $('Log Incoming Message').first().json;\nconst timestamp = new Date().toISOString();\n\nconsole.log('AI_FALLBACK:', JSON.stringify({\n  event: 'ai_fallback_triggered',\n  timestamp,\n  chat_id: inputCtx.chatId,\n  provider: 'gemini',\n  latencyMs: response._metadata.latencyMs\n}));\n\nreturn {\n  json: {\n    ...response,\n    _escalation: {\n      needed: false,\n      failureCount: 1\n    }\n  }\n};"
      },
      "id": "log-fallback",
      "name": "Log Fallback Event",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3000, 500]
    },
    {
      "parameters": {
        "jsCode": "const inputCtx = $('Log Incoming Message').first().json;\nconst error = $input.first().json.error?.message || 'Unknown error';\n\nconsole.log('GEMINI_FALLBACK_FAILED:', JSON.stringify({\n  timestamp: new Date().toISOString(),\n  chat_id: inputCtx.chatId,\n  error\n}));\n\nconst isQuotaError = error.includes('429') || error.toLowerCase().includes('quota');\n\nconst fallbackMessage = isQuotaError\n  ? \"AI capacity temporarily limited. Please try again later.\"\n  : \"AI systems experiencing temporary issues. Please try again.\";\n\nreturn {\n  json: {\n    output: fallbackMessage,\n    intermediate_steps: [],\n    _metadata: {\n      provider: 'none',\n      fallback: true,\n      complete_failure: true\n    }\n  }\n};"
      },
      "id": "handle-gemini-failure",
      "name": "Handle Gemini Failure",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2780, 640]
    },
    {
      "parameters": {
        "mode": "chooseBranch",
        "output": "empty"
      },
      "id": "merge-paths",
      "name": "Merge Paths",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [3220, 400]
    },
    {
      "parameters": {
        "jsCode": "const agent = $input.first().json;\nconst inputCtx = $('Log Incoming Message').first().json;\nconst timestamp = new Date().toISOString();\nconst executionId = $execution.id || 'N/A';\n\nconst toolCalls = agent.intermediate_steps || [];\nconst toolNames = toolCalls.map(step => step.tool || 'unknown');\n\nconst inputText = inputCtx.text || '';\nconst responseText = agent.output || '';\n\nlet toolConfidence = toolNames.length > 0 ? 100 : (responseText.length > 50 ? 60 : 30);\nconst provider = agent._metadata?.provider || 'ollama';\n\nconsole.log('ROUTING_DECISION:', JSON.stringify({\n  event: 'routing_decision',\n  timestamp,\n  executionId,\n  chat_id: inputCtx.chatId,\n  tools_called: toolNames,\n  provider,\n  fallback: agent._metadata?.fallback || false,\n  isVoice: inputCtx.isVoice || false,\n  input_length: inputText.length,\n  response_length: responseText.length\n}));\n\nreturn { json: agent };"
      },
      "id": "log-routing-decision",
      "name": "Log Routing Decision",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3440, 400]
    },
    {
      "parameters": {
        "jsCode": "// Phase 7+8: ADHD-Optimized Output Formatting + Button Templates\nconst ctx = $('Log Incoming Message').first().json;\nconst agent = $input.first().json;\n\nlet response = agent.output || agent.text || 'Processing complete.';\nlet buttons = null;\n\n// === BUTTON TEMPLATE FUNCTIONS (Phase 8) ===\nfunction confirmButtons(action, param) {\n  const suffix = param ? ':' + param : '';\n  return [[{ text: '‚úÖ Yes', callback_data: 'yes_' + action + suffix }, { text: '‚ùå No', callback_data: 'no_' + action + suffix }]];\n}\n\nfunction priorityButtons(taskId) {\n  const suffix = taskId ? ':' + taskId : '';\n  return [[{ text: 'üî¥ High', callback_data: 'set_priority:high' + suffix }, { text: 'üü° Medium', callback_data: 'set_priority:medium' + suffix }, { text: 'üü¢ Low', callback_data: 'set_priority:low' + suffix }]];\n}\n\nfunction detectButtonNeed(text) {\n  const lower = text.toLowerCase();\n  if (lower.includes('delete') || lower.includes('remove')) {\n    const target = text.match(/delete\\s+([\\w-]+)/i)?.[1] || 'item';\n    return { type: 'confirm', action: 'delete', param: target };\n  }\n  if (lower.includes('scan') && lower.includes('security')) {\n    const target = text.match(/scan\\s+([\\w.-]+)/i)?.[1] || 'target';\n    return { type: 'confirm', action: 'scan', param: target };\n  }\n  if (lower.includes('created task') || lower.includes('new task')) {\n    const taskId = text.match(/task[:\\s]+([\\w-]+)/i)?.[1] || '';\n    return { type: 'priority', taskId: taskId };\n  }\n  return null;\n}\n\nconst buttonNeed = detectButtonNeed(response);\nif (buttonNeed) {\n  if (buttonNeed.type === 'confirm') {\n    buttons = confirmButtons(buttonNeed.action, buttonNeed.param);\n    response += '\\n\\n‚ö†Ô∏è **Confirm action?**';\n  } else if (buttonNeed.type === 'priority') {\n    buttons = priorityButtons(buttonNeed.taskId);\n    response += '\\n\\nüìä **Set priority:**';\n  }\n}\n\n// === ADHD FORMATTING FUNCTIONS ===\nfunction boldKeywords(text) {\n  const statusWords = ['healthy', 'running', 'ready', 'complete', 'completed', 'success', 'failed', 'error', 'warning', 'critical', 'down', 'offline', 'online', 'active', 'inactive', 'enabled', 'disabled', 'started', 'stopped', 'pending', 'processing'];\n  text = text.replace(/(\\d+(?:\\.\\d+)?\\s*(?:GB|MB|KB|TB|ms|s|%|min|hour|day|week)s?)/gi, '**$1**');\n  statusWords.forEach(word => {\n    const regex = new RegExp('\\\\b(' + word + ')\\\\b', 'gi');\n    text = text.replace(regex, '**$1**');\n  });\n  text = text.replace(/\\*\\*\\*\\*([^*]+)\\*\\*\\*\\*/g, '**$1**');\n  return text;\n}\n\nfunction truncateBullets(text) {\n  const lines = text.split('\\n');\n  const result = [];\n  let bulletCount = 0;\n  let inBulletList = false;\n  let hiddenCount = 0;\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    const isBullet = /^[\\s]*[-‚Ä¢*]\\s/.test(line) || /^[\\s]*\\d+\\.\\s/.test(line);\n    if (isBullet) {\n      inBulletList = true;\n      bulletCount++;\n      if (bulletCount <= 3) {\n        let formattedLine = line;\n        if (line.toLowerCase().includes('healthy') || line.toLowerCase().includes('success')) {\n          formattedLine = line.replace(/^([\\s]*[-‚Ä¢*]\\s)/, '$1‚úÖ ');\n        } else if (line.toLowerCase().includes('error') || line.toLowerCase().includes('failed')) {\n          formattedLine = line.replace(/^([\\s]*[-‚Ä¢*]\\s)/, '$1‚ùå ');\n        } else if (line.toLowerCase().includes('warning')) {\n          formattedLine = line.replace(/^([\\s]*[-‚Ä¢*]\\s)/, '$1‚ö†Ô∏è ');\n        }\n        result.push(formattedLine);\n      } else {\n        hiddenCount++;\n      }\n    } else {\n      if (inBulletList && hiddenCount > 0) {\n        result.push('... and ' + hiddenCount + ' more');\n        hiddenCount = 0;\n        bulletCount = 0;\n      }\n      inBulletList = false;\n      bulletCount = 0;\n      result.push(line);\n    }\n  }\n  if (hiddenCount > 0) {\n    result.push('... and ' + hiddenCount + ' more');\n  }\n  return result.join('\\n');\n}\n\nfunction extractNextStep(text) {\n  if (text.toLowerCase().includes('next step:')) return text;\n  const patterns = [/you should ([^.!?]+)/i, /please ([^.!?]+)/i, /try ([^.!?]+)/i, /run ([^.!?]+)/i, /check ([^.!?]+)/i];\n  for (const pattern of patterns) {\n    const match = text.match(pattern);\n    if (match && match[1]) {\n      const action = match[1].trim();\n      return text + '\\n\\n**Next step:** ' + action.charAt(0).toUpperCase() + action.slice(1);\n    }\n  }\n  return text;\n}\n\nfunction addTldr(text) {\n  if (text.length <= 300) return text;\n  let tldr = '';\n  const firstSentence = text.match(/^[^.!?]+[.!?]/)?.[0] || '';\n  if (firstSentence && firstSentence.length <= 100) {\n    tldr = firstSentence.trim();\n  } else {\n    tldr = text.substring(0, 97).trim();\n    const lastSpace = tldr.lastIndexOf(' ');\n    if (lastSpace > 50) tldr = tldr.substring(0, lastSpace);\n    tldr += '...';\n  }\n  return '**TL;DR:** ' + tldr + '\\n\\n_(Tap gray box for details)_\\n\\n||' + text + '||';\n}\n\n// Apply formatting\nresponse = boldKeywords(response);\nresponse = truncateBullets(response);\nresponse = extractNextStep(response);\nresponse = addTldr(response);\n\nif (response.length > 4000) response = response.substring(0, 3997) + '...';\n\nconsole.log('ADHD_FORMAT:', JSON.stringify({ originalLen: (agent.output || '').length, formattedLen: response.length, hasButtons: !!buttons }));\n\nreturn { json: { chatId: ctx.chatId, messageId: ctx.messageId, text: response, buttons: buttons } };"
      },
      "id": "format-output",
      "name": "Format Output (ADHD)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3660, 400]
    },
    {
      "parameters": {
        "jsCode": "const startTime = $('Log Incoming Message').first().json.timestamp;\nconst response = $input.first().json;\nconst timestamp = new Date().toISOString();\nconst executionId = $execution.id || 'N/A';\n\nconst latencyMs = startTime \n  ? new Date(timestamp).getTime() - new Date(startTime).getTime() \n  : null;\n\nconsole.log('SUPERVISOR_AGENT_OUTGOING:', JSON.stringify({\n  event: 'message_sent',\n  timestamp,\n  chatId: response.chatId,\n  responseLength: (response.text || '').length,\n  latencyMs,\n  executionId,\n  messageId: response.messageId\n}));\n\nreturn { json: response };"
      },
      "id": "log-outgoing",
      "name": "Log Outgoing Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3880, 400]
    },
    {
      "parameters": {
        "chatId": "={{ $json.chatId }}",
        "text": "={{ $json.text }}",
        "additionalFields": {
          "parse_mode": "MarkdownV2",
          "reply_markup": "={{ $json.buttons ? JSON.stringify({ inline_keyboard: $json.buttons }) : '' }}"
        }
      },
      "id": "send-response",
      "name": "Send Response",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [4100, 400],
      "credentials": {
        "telegramApi": {
          "id": "telegram-bot-main",
          "name": "Telegram Bot"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE telegram_message_log\nSET status = 'completed', processed_at = NOW()\nWHERE message_id = $1;",
        "options": {
          "queryReplacement": "={{ $json.messageId }}"
        }
      },
      "id": "mark-complete",
      "name": "Mark Complete",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [4320, 400],
      "credentials": {
        "postgres": {
          "id": "cd-postgres-main",
          "name": "CD PostgreSQL"
        }
      }
    }
  ],
  "connections": {
    "Telegram Ingestion": {
      "main": [[{ "node": "Extract Message ID", "type": "main", "index": 0 }]]
    },
    "Extract Message ID": {
      "main": [[{ "node": "Check Duplicate", "type": "main", "index": 0 }]]
    },
    "Check Duplicate": {
      "main": [[{ "node": "Is Duplicate?", "type": "main", "index": 0 }]]
    },
    "Is Duplicate?": {
      "main": [
        [{ "node": "Skip Duplicate", "type": "main", "index": 0 }],
        [{ "node": "Is Callback?", "type": "main", "index": 0 }]
      ]
    },
    "Is Callback?": {
      "main": [
        [{ "node": "Parse Callback", "type": "main", "index": 0 }],
        [{ "node": "Parse Input", "type": "main", "index": 0 }]
      ]
    },
    "Parse Callback": {
      "main": [[{ "node": "Button Expired?", "type": "main", "index": 0 }]]
    },
    "Button Expired?": {
      "main": [
        [{ "node": "Answer Expired", "type": "main", "index": 0 }],
        [{ "node": "Acknowledge Callback", "type": "main", "index": 0 }]
      ]
    },
    "Acknowledge Callback": {
      "main": [[{ "node": "Route Callback", "type": "main", "index": 0 }]]
    },
    "Route Callback": {
      "main": [[{ "node": "Edit Message", "type": "main", "index": 0 }]]
    },
    "Edit Message": {
      "main": [[{ "node": "Log Button Interaction", "type": "main", "index": 0 }]]
    },
    "Parse Input": {
      "main": [[{ "node": "Is Voice?", "type": "main", "index": 0 }]]
    },
    "Is Voice?": {
      "main": [
        [{ "node": "Send Transcribing Status", "type": "main", "index": 0 }],
        [{ "node": "Log Incoming Message", "type": "main", "index": 0 }]
      ]
    },
    "Send Transcribing Status": {
      "main": [[{ "node": "Get Voice File Info", "type": "main", "index": 0 }]]
    },
    "Get Voice File Info": {
      "main": [[{ "node": "Download Voice File", "type": "main", "index": 0 }]]
    },
    "Download Voice File": {
      "main": [[{ "node": "Transcribe Voice", "type": "main", "index": 0 }]]
    },
    "Transcribe Voice": {
      "main": [[{ "node": "Parse Transcription", "type": "main", "index": 0 }]]
    },
    "Parse Transcription": {
      "main": [[{ "node": "Transcription OK?", "type": "main", "index": 0 }]]
    },
    "Transcription OK?": {
      "main": [
        [{ "node": "Send Transcription Error", "type": "main", "index": 0 }],
        [{ "node": "Echo Transcription", "type": "main", "index": 0 }]
      ]
    },
    "Echo Transcription": {
      "main": [[{ "node": "Log Incoming Message", "type": "main", "index": 0 }]]
    },
    "Log Incoming Message": {
      "main": [[{ "node": "Ollama Agent Wrapper", "type": "main", "index": 0 }]]
    },
    "Ollama Agent Wrapper": {
      "main": [[{ "node": "Supervisor Agent", "type": "main", "index": 0 }]]
    },
    "Chat Memory": {
      "ai_memory": [[{ "node": "Supervisor Agent", "type": "ai_memory", "index": 0 }]]
    },
    "Ollama Qwen": {
      "ai_languageModel": [[{ "node": "Supervisor Agent", "type": "ai_languageModel", "index": 0 }]]
    },
    "ADHD Commander Tool": {
      "ai_tool": [[{ "node": "Supervisor Agent", "type": "ai_tool", "index": 0 }]]
    },
    "Finance Manager Tool": {
      "ai_tool": [[{ "node": "Supervisor Agent", "type": "ai_tool", "index": 0 }]]
    },
    "System Status Tool": {
      "ai_tool": [[{ "node": "Supervisor Agent", "type": "ai_tool", "index": 0 }]]
    },
    "Supervisor Agent": {
      "main": [[{ "node": "Check Agent Success", "type": "main", "index": 0 }]]
    },
    "Check Agent Success": {
      "main": [
        [{ "node": "Merge Paths", "type": "main", "index": 0 }],
        [{ "node": "Prepare Gemini Fallback", "type": "main", "index": 0 }]
      ]
    },
    "Prepare Gemini Fallback": {
      "main": [[{ "node": "Call Gemini API", "type": "main", "index": 0 }]]
    },
    "Call Gemini API": {
      "main": [
        [{ "node": "Parse Gemini Response", "type": "main", "index": 0 }],
        [{ "node": "Handle Gemini Failure", "type": "main", "index": 0 }]
      ]
    },
    "Parse Gemini Response": {
      "main": [[{ "node": "Log Fallback Event", "type": "main", "index": 0 }]]
    },
    "Log Fallback Event": {
      "main": [[{ "node": "Merge Paths", "type": "main", "index": 1 }]]
    },
    "Handle Gemini Failure": {
      "main": [[{ "node": "Merge Paths", "type": "main", "index": 1 }]]
    },
    "Merge Paths": {
      "main": [[{ "node": "Log Routing Decision", "type": "main", "index": 0 }]]
    },
    "Log Routing Decision": {
      "main": [[{ "node": "Format Output (ADHD)", "type": "main", "index": 0 }]]
    },
    "Format Output (ADHD)": {
      "main": [[{ "node": "Log Outgoing Response", "type": "main", "index": 0 }]]
    },
    "Log Outgoing Response": {
      "main": [[{ "node": "Send Response", "type": "main", "index": 0 }]]
    },
    "Send Response": {
      "main": [[{ "node": "Mark Complete", "type": "main", "index": 0 }]]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "errorWorkflow": "System: Error Handler"
  },
  "staticData": null,
  "tags": [
    { "name": "12WY" },
    { "name": "Supervisor" },
    { "name": "Agentic" },
    { "name": "Dedup" },
    { "name": "Resilient" },
    { "name": "Voice" },
    { "name": "ADHD" },
    { "name": "Buttons" }
  ],
  "meta": {
    "notes": "Supervisor Agent v7.0 (Interactive Buttons): Added Telegram inline button support. Features: (1) Callback handler with 5-min expiration, (2) Yes/No confirmation buttons, (3) Priority selector buttons, (4) Auto-detect destructive actions. Satisfies SC-8.1 through SC-8.4. Previous: ADHD formatting, Voice pipeline, Gemini fallback.",
    "templateCredsSetupCompleted": true,
    "toolInventory": {
      "ADHD_Commander": "Task prioritization and focus guidance from Notion",
      "Finance_Manager": "Transaction logging and financial tracking",
      "System_Status": "Infrastructure health checks and system monitoring"
    },
    "fallbackConfig": {
      "primary": "ollama-qwen2.5:7b",
      "secondary": "gemini-2.0-flash",
      "escalationThreshold": 3
    },
    "voiceConfig": {
      "whisperModel": "base",
      "whisperLanguage": "en",
      "maxDuration": 60
    },
    "adhdConfig": {
      "tldrThreshold": 300,
      "maxTldrLength": 100,
      "maxBullets": 3,
      "parseMode": "MarkdownV2"
    },
    "buttonConfig": {
      "expirationSeconds": 300,
      "confirmActions": ["delete", "scan", "restart", "deploy"],
      "priorityActions": ["create_task", "set_priority"],
      "templates": ["yes_no", "priority", "menu"]
    }
  }
}
