---
phase: 08-interactive-ui
plan: 01
type: execute
wave: 1
depends_on: []
files_created:
  - COREDIRECTIVE_ENGINE/workflows/callback_handler.json

must_haves:
  truths:
    - "Telegram inline buttons trigger n8n workflows"
    - "Callback queries route to correct handlers"
  artifacts:
    - path: "COREDIRECTIVE_ENGINE/workflows/callback_handler.json"
      provides: "Central callback query router"
      contains: "Webhook for callback_query events"
---

<objective>
Create callback query handler for Telegram inline buttons.

Purpose: Enable interactive UI elements (buttons) so critical actions require explicit confirmation. This prevents accidental destructive actions and improves ADHD decision-making.

Output: Central webhook handler that receives button clicks and routes to appropriate action workflows.
</objective>

<execution_context>
@/Users/et/.claude/get-shit-done/workflows/execute-plan.md
@/Users/et/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
Telegram callback_query: https://core.telegram.org/bots/api#callbackquery
</context>

<tasks>

<task type="auto">
  <name>Task 1: Register callback_query webhook</name>
  <files>COREDIRECTIVE_ENGINE/workflows/callback_handler.json</files>
  <action>
    Create n8n workflow with Telegram Trigger (Webhook):

    Configuration:
    - Trigger type: callback_query
    - Webhook path: /callback
    - Method: POST

    This creates a second webhook (separate from message webhook) specifically for button clicks.

    Telegram sends callback_query when user taps inline button:
    ```json
    {
      "callback_query": {
        "id": "123456",
        "from": {...},
        "message": {...},
        "data": "action:param1:param2"
      }
    }
    ```

    The `data` field contains the button action we defined.

    Note: Must register this webhook via Telegram setWebhook API
  </action>
  <verify>
    # Check n8n has webhook trigger for callback_query
    # URL should be: https://cyber-squire.tigouetheory.com/webhook/callback
  </verify>
  <done>callback_query webhook registered and listening</done>
</task>

<task type="auto">
  <name>Task 2: Parse callback data and route</name>
  <files>COREDIRECTIVE_ENGINE/workflows/callback_handler.json</files>
  <action>
    Add routing logic based on callback data:

    Callback data format: "action:param1:param2:..."

    Examples:
    - "confirm_scan:example.com"
    - "priority_select:high:task_123"
    - "yes_delete:workflow_456"
    - "no_cancel:workflow_456"

    Routing:
    1. Code node: Parse callback data
       ```javascript
       const data = $json.callback_query.data;
       const parts = data.split(':');
       return {
         action: parts[0],
         params: parts.slice(1)
       };
       ```

    2. Switch node: Route by action type
       - Case "confirm_scan": Execute security scan workflow
       - Case "priority_select": Execute priority update workflow
       - Case "yes_*": Execute confirmation action
       - Case "no_*": Send cancellation message
       - Default: Error handler

    This central router keeps button logic organized.
  </action>
  <verify>
    # Test button with data "test_action:param1"
    # Verify routing logic extracts action and params correctly
  </verify>
  <done>Callback data parsed and routed to correct handlers</done>
</task>

<task type="auto">
  <name>Task 3: Add button expiration check</name>
  <files>COREDIRECTIVE_ENGINE/workflows/callback_handler.json</files>
  <action>
    Prevent stale button clicks (>5 minutes old):

    1. Code node: Calculate button age
       ```javascript
       const buttonTimestamp = $json.callback_query.message.date;
       const now = Math.floor(Date.now() / 1000);
       const age_seconds = now - buttonTimestamp;

       return {
         age_seconds,
         is_expired: age_seconds > 300 // 5 minutes
       };
       ```

    2. IF node: Check is_expired
       - If TRUE: Answer callback with error
       - If FALSE: Continue to routing

    3. Telegram answerCallbackQuery with expiration message:
       ```json
       {
         "callback_query_id": "{{$json.callback_query.id}}",
         "text": "This button expired (5+ minutes old). Please request a new action.",
         "show_alert": true
       }
       ```

    This prevents executing actions on old messages.
  </action>
  <verify>
    # Create test button
    # Wait 6 minutes
    # Click button
    # Should see "button expired" alert
  </verify>
  <done>Button expiration prevents stale actions</done>
</task>

<task type="auto">
  <name>Task 4: Add callback acknowledgment</name>
  <files>COREDIRECTIVE_ENGINE/workflows/callback_handler.json</files>
  <action>
    Always acknowledge button clicks immediately:

    After routing but before executing action:
    1. Telegram answerCallbackQuery (empty response)
       - This removes the loading spinner on the button
       - Must be called within 30 seconds of click

    ```json
    {
      "callback_query_id": "{{$json.callback_query.id}}"
    }
    ```

    Optional: Include text for toast notification
    ```json
    {
      "callback_query_id": "{{$json.callback_query.id}}",
      "text": "Processing your request..."
    }
    ```

    Note: This is separate from the final result message
  </action>
  <verify>
    # Click button
    # Loading spinner should disappear immediately
    # Toast notification appears (if text provided)
  </verify>
  <done>Callback acknowledgment provides immediate feedback</done>
</task>

<task type="auto">
  <name>Task 5: Add callback logging</name>
  <files>COREDIRECTIVE_ENGINE/workflows/callback_handler.json</files>
  <action>
    Log all button clicks to PostgreSQL:

    Table: button_interactions
    Fields:
    - callback_query_id (unique ID from Telegram)
    - user_id
    - action (parsed from callback data)
    - params (JSON array)
    - button_age_seconds
    - is_expired
    - timestamp

    This enables debugging and usage analytics.

    SQL:
    ```sql
    INSERT INTO button_interactions
    (callback_query_id, user_id, action, params, button_age_seconds, is_expired)
    VALUES ($1, $2, $3, $4, $5, $6);
    ```
  </action>
  <verify>
    # Click button
    # Check database for log entry
    SELECT * FROM button_interactions ORDER BY timestamp DESC LIMIT 1;
  </verify>
  <done>All button interactions logged to database</done>
</task>

</tasks>

<verification>
1. Create test workflow with inline button
2. Click button and verify callback handler triggers
3. Verify routing logic extracts action and params
4. Verify expired button (>5 min) shows error
5. Verify loading spinner disappears on click
6. Verify button click logged to database
</verification>

<success_criteria>
- callback_query webhook receives button clicks
- Callback data parsed and routed correctly
- Expired buttons rejected with error message
- Immediate acknowledgment removes loading spinner
- All interactions logged to database
</success_criteria>

<output>
After completion, create `.planning/phases/08-interactive-ui/08-01-SUMMARY.md`
</output>
